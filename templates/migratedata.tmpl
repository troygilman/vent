{{ define "migrate/migratedata/migratedata" }}

package migratedata

import (
	"context"
	"errors"
	"fmt"
	"net/url"

	"ariga.io/atlas/sql/migrate"
	"ariga.io/atlas/sql/sqlclient"
	"entgo.io/ent/dialect"
	entsql "entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/schema"
)

var metadata = map[string]vent.VentSchemaAnnotation{
    {{ range $node := $.Nodes }}
    {{ $annotation := $node.Annotations.VentSchema }}
    "{{ lower $node.Name }}": {
        Permissions: []vent.Permission{
            {{ range $permission := $annotation.Permissions }}
            {
                Name: "{{ $permission.Name }}",
            },
            {{ end }}
        },
    },
    {{ end }}
}

func Diff(ctx context.Context, u string, dir migrate.Dir, formatter migrate.Formatter) error {
	parsedUrl, err := url.Parse(u)
	if err != nil {
		return err
	}

	client, err := sqlclient.OpenURL(ctx, parsedUrl)
	if err != nil {
		return err
	}
	defer client.Close()

	return NewDiffer(client, dir, formatter).Diff(ctx)
}

type Differ struct {
	flush       bool
	dir         migrate.Dir
	writer      *schema.DirWriter
	driver      migrate.Driver
	readClient  *ent.Client
	writeClient *ent.Client
}

func NewDiffer(client *sqlclient.Client, dir migrate.Dir, formatter migrate.Formatter) *Differ {
	writer := &schema.DirWriter{Dir: dir, Formatter: formatter}
	return &Differ{
		driver:      client.Driver,
		writer:      writer,
		dir:         dir,
		readClient:  ent.NewClient(ent.Driver(entsql.OpenDB(dialect.SQLite, client.DB))),
		writeClient: ent.NewClient(ent.Driver(schema.NewWriteDriver(dialect.SQLite, writer))),
	}
}

func (d *Differ) Diff(ctx context.Context) error {
	if err := d.replayMigrations(ctx); err != nil {
		return err
	}

	if err := d.diffAuthPermissions(ctx); err != nil {
		return err
	}

	if d.flush {
		return d.writer.Flush("update_auth_permissions")
	}
	return nil

}

func (d *Differ) replayMigrations(ctx context.Context) error {
	ex, err := migrate.NewExecutor(d.driver, d.dir, &migrate.NopRevisionReadWriter{})
	if err != nil {
		return err
	}
	if err := ex.ExecuteN(ctx, 0); err != nil && !errors.Is(err, migrate.ErrNoPendingFiles) {
		return err
	}
	return nil
}

func (d *Differ) diffAuthPermissions(ctx context.Context) error {
	currentPermissions, err := d.readClient.AuthPermission.Query().All(ctx)
	if err != nil {
		return err
	}

	currentPermissionsMap := make(map[string]*ent.AuthPermission)
	for _, permission := range currentPermissions {
		currentPermissionsMap[permission.Name] = permission
	}

	permissionBuilders := []*ent.AuthPermissionCreate{}
	for schemaName, annotation := range metadata {
		for _, action := range []string{"create", "read", "update", "delete"} {
			permissionName := fmt.Sprintf("%s_%s", action, schemaName)
			_, ok := currentPermissionsMap[permissionName]
			if !ok {
				permissionBuilders = append(permissionBuilders, d.writeClient.AuthPermission.Create().SetName(permissionName))
			}
		}
		for _, permission := range annotation.Permissions {
			_, ok := currentPermissionsMap[permission.Name]
			if !ok {
				permissionBuilders = append(permissionBuilders, d.writeClient.AuthPermission.Create().SetName(permission.Name))
			}
		}
	}

	permissions, err := d.writeClient.AuthPermission.CreateBulk(permissionBuilders...).Save(ctx)
	if err != nil {
		return err
	}

	if len(permissions) > 0 {
		d.writer.Change("Added permissions")
		d.flush = true
	}

	return nil
}

{{ end }}
