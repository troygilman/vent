{{ define "migrate/migratedata/migratedata" }}

package migratedata

import (
	"context"
	"errors"
	"fmt"
	"net/url"

	"ariga.io/atlas/sql/migrate"
	"ariga.io/atlas/sql/sqlclient"
	"entgo.io/ent/dialect"
	entsql "entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/schema"
)

var metadata = map[string]vent.VentSchemaAnnotation{
    {{ range $node := $.Nodes }}
    {{ $annotation := $node.Annotations.VentSchema }}
    "{{ lower $node.Name }}": {
        Permissions: []vent.Permission{
            {{ range $permission := $annotation.Permissions }}
            {
                Name: "{{ $permission.Name }}",
            },
            {{ end }}
        },
    },
    {{ end }}
}

func Diff(ctx context.Context, u string, dir migrate.Dir, formatter migrate.Formatter) error {
	parsed, err := url.Parse(u)
	if err != nil {
		return err
	}

	client, err := sqlclient.OpenURL(ctx, parsed)
	if err != nil {
		return err
	}
	defer client.Close()

	w := &schema.DirWriter{Dir: dir, Formatter: formatter}
	writeClient := ent.NewClient(ent.Driver(schema.NewWriteDriver(dialect.SQLite, w)))

	d := &Differ{
		dir:         dir,
		driver:      client.Driver,
		readClient:  ent.NewClient(ent.Driver(entsql.OpenDB(dialect.SQLite, client.DB))),
		writeClient: writeClient,
	}

	if err := d.replayMigrations(ctx); err != nil {
		return err
	}

	if err := d.updateAuthPermissions(ctx); err != nil {
		return err
	}

	if d.flush {
		return w.FlushChange("update_auth_permissions", "Update auth permissions")
	}
	return nil
}

type Differ struct {
	flush       bool
	dir         migrate.Dir
	driver      migrate.Driver
	readClient  *ent.Client
	writeClient *ent.Client
}

func (d *Differ) replayMigrations(ctx context.Context) error {
	ex, err := migrate.NewExecutor(d.driver, d.dir, &migrate.NopRevisionReadWriter{})
	if err != nil {
		return err
	}
	if err := ex.ExecuteN(ctx, 0); err != nil && !errors.Is(err, migrate.ErrNoPendingFiles) {
		return err
	}
	return nil
}

func (d *Differ) updateAuthPermissions(ctx context.Context) error {
	currentPermissions, err := d.readClient.AuthPermission.Query().All(ctx)
	if err != nil {
		return err

	}

	currentPermissionsMap := make(map[string]*ent.AuthPermission)
	for _, permission := range currentPermissions {
		currentPermissionsMap[permission.Name] = permission
	}

	permissionBuilders := []*ent.AuthPermissionCreate{}
	for schemaName, annotation := range metadata {
		for _, permission := range annotation.Permissions {
			_, ok := currentPermissionsMap[permission.Name]
			if !ok {
				permissionBuilders = append(permissionBuilders, d.writeClient.AuthPermission.Create().SetName(permission.Name))
			}
		}
		for _, action := range []string{"create", "read", "update", "delete"} {
			permissionName := fmt.Sprintf("%s_%s", action, schemaName)
			_, ok := currentPermissionsMap[permissionName]
			if !ok {
				permissionBuilders = append(permissionBuilders, d.writeClient.AuthPermission.Create().SetName(permissionName))
			}
		}
	}

	permissions, err := d.writeClient.AuthPermission.CreateBulk(permissionBuilders...).Save(ctx)
	if err != nil {
		return err
	}

	if len(permissions) > 0 {
		d.flush = true
	}

	return nil
}


{{ end }}
