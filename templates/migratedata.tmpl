{{ define "migrate/migratedata/migratedata" }}

package migratedata

type Metadata struct {
	Schemas map[string]vent.VentSchemaAnnotation `json:"schemas"`
}

var metadata = Metadata{
	Schemas: map[string]vent.VentSchemaAnnotation{
	    {{ range $node := $.Nodes }}
        "{{ lower $node.Name }}": vent.VentSchemaAnnotation{}.MustParse(`{{ stringify $node.Annotations.VentSchema }}`),
        {{ end }}
	},
}

func UpdateAuthPermissions(dir *migrate.LocalDir) error {
	prevMetadata, err := loadPrevMetadata("ent/migrate/migrations/meta.json")
	if err != nil {
		return err
	}

	ctx := context.Background()
	w := &schema.DirWriter{Dir: dir}
	client := ent.NewClient(ent.Driver(schema.NewWriteDriver(dialect.SQLite, w)))
	isChanged := false

	for schemaName, annotation := range metadata.Schemas {
		prevAnnotation, ok := prevMetadata.Schemas[schemaName]
		if ok {
			prevPermissions := prevAnnotation.PermissionMap()
			for _, permission := range annotation.Permissions {
				_, ok := prevPermissions[permission.Name]
				if !ok {
					isChanged = true
					_, err := client.AuthPermission.Create().SetName(permission.Name).Save(ctx)
					if err != nil {
						panic(err)
					}
				}
			}
		} else {
			isChanged = true
			defaultPermNames := []string{"create", "read", "update", "delete"}
			client.AuthPermission.MapCreateBulk(defaultPermNames, func(apc *ent.AuthPermissionCreate, i int) {
				_, err := apc.SetName(fmt.Sprintf("%s_%s", defaultPermNames[i], schemaName)).Save(ctx)
				if err != nil {
					panic(err)
				}
			})
		}
	}

	if isChanged {
		if err := w.FlushChange(
			"update_auth_permissions",
			"Backfill all empty user names with default value 'unknown'.",
		); err != nil {
			return err
		}
	}

	buf, err := json.Marshal(&metadata)
	if err != nil {
		return err
	}

	if err := os.WriteFile("ent/migrate/migrations/meta.json", buf, 0644); err != nil {
		return err
	}

	return nil
}

func loadPrevMetadata(name string) (meta Metadata, err error) {
	file, err := os.OpenFile(name, os.O_RDONLY|os.O_CREATE, 0666)
	if err != nil {
		return meta, err
	}
	defer file.Close()

	buf, err := io.ReadAll(file)
	if err != nil {
		return meta, err
	}

	if len(buf) == 0 {
		return meta, nil
	}

	prevMetadata := Metadata{}
	if err := json.Unmarshal(buf, &prevMetadata); err != nil {
		return meta, err
	}

	return prevMetadata, nil
}

{{ end }}
