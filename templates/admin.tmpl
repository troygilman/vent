{{ define "vent_admin" }}

{{ $pkg := base $.Config.Package }}
{{ template "header" $ }}

{{ $adminPath := $.Annotations.VentConfig.AdminPath }}

import (
	"context"
	"fmt"
	"net/http"
	"vent"
	"vent/auth"

	"entgo.io/ent/dialect/sql"
)

type AdminConfig struct {
	Client         *Client
	SecretProvider auth.SecretProvider
}

func NewAdminHandler(config AdminConfig) http.Handler {
	credentialAuthenticator := auth.NewBCryptCredentialAuthenticator()
	credentialGenerator := auth.NewBCryptCredentialGenerator()

	{{ range $node := $.Nodes }}
	{{ $pwFields := passwordFields $node }}
	{{ $schemaAnnotation := parseSchemaAnnotation $node }}
	schema{{ $node.Name }} := vent.SchemaConfig{
	    AdminEnabled: {{ not $schemaAnnotation.DisableAdmin }},
		Name: "{{ $node.Name }}",
		Client: &{{ $node.Name }}SchemaClient{
			client: config.Client,
		},
		{{ if eq $schemaAnnotation.DisplayField "" }}
		DisplayField: "id",
		{{ else }}
		DisplayField: "{{ $schemaAnnotation.DisplayField }}",
		{{ end }}
		Fields: []vent.FieldConfig{
		    {
			    Name: "id",
				Label: "ID",
				Type: vent.TypeInt,
				Editable: false,
			},
			{{ range $field := fields $node }}
			{
				Name:     "{{ $field.Name }}",
				Label:    "{{ pascal $field.Name }}",
				Type:     vent.Type{{ pascal $field.Type }},
				InputType: "{{ $field.InputType }}",
				Editable: {{ not $field.Sensitive }},
			},
			{{ end }}
			{{- range $edge := $node.Edges }}
			{
				Name:     "{{ $edge.Name }}",
				Label:    "{{ pascal $edge.Name }}",
				{{ if $edge.Unique }}
				Type:     vent.TypeForeignKeyUnique,
				{{ else }}
				Type:     vent.TypeForeignKey,
				{{ end }}
				Editable: true,
				Relation: &vent.RelationDef{
					TargetSchema:  "{{ $edge.Type.Name }}",
					TargetDisplay: "id",
					TargetPath:    "{{ $adminPath }}{{ lower $edge.Type.Name }}s/",
					Unique: {{ $edge.Unique }},
				},
			},
			{{- end }}
		},
		FieldSets: []vent.FieldSet{
		    {{- range $set := fieldSets $node }}
			{
			    Label: "{{ $set.Label }}",
				Fields: []string{
				    {{- range $field := $set.Fields }}
					"{{ $field }}",
				    {{- end }}
				},
			},
			{{- end }}
		},
		Columns: []string{
		    {{- range $col := tableColumns $node }}
			"{{ $col }}",
			{{- end }}
		},
		{{- if $pwFields }}
		FieldMappers: vent.ChainFieldMappers(
			{{- range $field := $pwFields }}
			vent.HashPassword("{{ trimSuffix $field.Name "_hash" }}", "{{ $field.Name }}", credentialGenerator),
			{{- end }}
		),
		{{- end }}
	}
	{{ end }}

	handler := vent.NewHandler(vent.HandlerConfig{
		SecretProvider:          config.SecretProvider,
		CredentialAuthenticator: credentialAuthenticator,
		AuthUserSchema:          schema{{ $.Annotations.VentConfig.UserSchema }},
		AuthPasswordField:       "password_hash",
		BasePath:                "{{ $adminPath }}",
	})

	{{ range $node := $.Nodes }}
	handler.RegisterSchema(schema{{ $node.Name }})
	{{ end }}

	return handler
}

{{ range $node := $.Nodes }}

// {{ $node.Name }}SchemaClient implements vent.SchemaClient for {{ $node.Name }} entities
type {{ $node.Name }}SchemaClient struct {
	client *Client
}

func (c *{{ $node.Name }}SchemaClient) List(ctx context.Context, opts vent.QueryOptions) ([]vent.EntityData, error) {
	q := c.client.{{ $node.Name }}.Query()

	// Apply ordering
	if opts.OrderBy != "" {
		switch opts.OrderBy {
		case "id":
			if opts.OrderDesc {
				q = q.Order({{ lower $node.Name }}.ByID(sql.OrderDesc()))
			} else {
				q = q.Order({{ lower $node.Name }}.ByID())
			}
		{{ range $field := $node.Fields }}
		case "{{ $field.Name }}":
			if opts.OrderDesc {
				q = q.Order({{ lower $node.Name }}.By{{ pascal $field.Name }}(sql.OrderDesc()))
			} else {
				q = q.Order({{ lower $node.Name }}.By{{ pascal $field.Name }}())
			}
		{{ end }}
		}
	}

	// Apply filters
	for key, value := range opts.Filters {
		switch key {
		case "id":
			q = q.Where({{ lower $node.Name }}.IDEQ(value.(int)))
		{{ range $field := $node.Fields }}
		case "{{ $field.Name }}":
			q = q.Where({{ lower $node.Name }}.{{ pascal $field.Name }}EQ(value.({{ $field.Type }})))
		{{ end }}
		}
	}

	// Apply limit/offset
	if opts.Limit > 0 {
		q = q.Limit(opts.Limit)
	}
	if opts.Offset > 0 {
		q = q.Offset(opts.Offset)
	}

	// Eager load foreign key edges
	{{- range $edge := $node.Edges }}
	{{- if $edge.Unique }}
	q = q.With{{ pascal $edge.Name }}()
	{{- end }}
	{{- end }}

	// Eager load requested edges (single query with nested With* calls)
	if len(opts.WithEdges) > 0 {
		edgePaths := vent.ParseEdgePaths(opts.WithEdges)
		q = apply{{ $node.Name }}WithEdges(q, edgePaths)
	}

	entities, err := q.All(ctx)
	if err != nil {
		return nil, err
	}

	results := make([]vent.EntityData, len(entities))
	for i, e := range entities {
		results[i] = {{ lower $node.Name }}ToEntityData(e)
	}
	return results, nil
}

func (c *{{ $node.Name }}SchemaClient) Get(ctx context.Context, id int, opts ...vent.GetOptions) (vent.EntityData, error) {
	q := c.client.{{ $node.Name }}.Query().Where({{ lower $node.Name }}.IDEQ(id))

	// Eager load foreign key edges
	{{- range $edge := $node.Edges }}
	{{- if $edge.Unique }}
	q = q.With{{ pascal $edge.Name }}()
	{{- end }}
	{{- end }}

	// Eager load requested edges (single query with nested With* calls)
	if len(opts) > 0 && len(opts[0].WithEdges) > 0 {
		edgePaths := vent.ParseEdgePaths(opts[0].WithEdges)
		q = apply{{ $node.Name }}WithEdges(q, edgePaths)
	}

	e, err := q.Only(ctx)
	if err != nil {
		return nil, err
	}

	return {{ lower $node.Name }}ToEntityData(e), nil
}

func (c *{{ $node.Name }}SchemaClient) Create(ctx context.Context, data map[string]any) (vent.EntityData, error) {
	builder := c.client.{{ $node.Name }}.Create()

	{{ range $field := $node.Fields }}
	if v, ok := data["{{ $field.Name }}"]; ok {
		builder = builder.Set{{ pascal $field.Name }}(v.({{ $field.Type }}))
	}
	{{ end }}

	{{- range $edge := $node.Edges }}
	{{ $edgeName := pascal $edge.Name }}
	if v, ok := data["{{ $edge.Name }}"]; ok {
		if ids := v.([]int); len(ids) > 0 {
		    builder = builder.Add{{ trimSuffix $edgeName "s" }}IDs(ids...)
		}
	}
	{{- end }}

	e, err := builder.Save(ctx)
	if err != nil {
		return nil, err
	}
	return {{ lower $node.Name }}ToEntityData(e), nil
}

func (c *{{ $node.Name }}SchemaClient) Update(ctx context.Context, id int, data map[string]any) error {
	builder := c.client.{{ $node.Name }}.UpdateOneID(id)

	{{ range $field := $node.Fields }}
	if v, ok := data["{{ $field.Name }}"]; ok {
		builder = builder.Set{{ pascal $field.Name }}(v.({{ $field.Type }}))
	}
	{{ end }}

	{{- range $edge := $node.Edges }}
	{{ $edgeName := pascal $edge.Name }}
	if v, ok := data["{{ $edge.Name }}"]; ok {
	    builder = builder.Clear{{ $edgeName }}()
		if ids := v.([]int); len(ids) > 0 {
		    builder = builder.Add{{ trimSuffix $edgeName "s" }}IDs(ids...)
		}
	}
	{{- end }}

	return builder.Exec(ctx)
}

func (c *{{ $node.Name }}SchemaClient) Delete(ctx context.Context, id int) error {
	return c.client.{{ $node.Name }}.DeleteOneID(id).Exec(ctx)
}

func (c *{{ $node.Name }}SchemaClient) GetRelationOptions(ctx context.Context, relation *vent.RelationDef) ([]vent.SelectOption, error) {
	switch relation.TargetSchema {
	{{- range $edge := $node.Edges }}
	{{- if $edge.Unique }}
	case "{{ $edge.Type.Name }}":
		entities, err := c.client.{{ $edge.Type.Name }}.Query().All(ctx)
		if err != nil {
			return nil, err
		}
		options := make([]vent.SelectOption, len(entities))
		for i, e := range entities {
			options[i] = vent.SelectOption{
				Value: e.ID,
				Label: fmt.Sprintf("%d", e.ID), // TODO: Use display field
			}
		}
		return options, nil
	{{- end }}
	{{- end }}
	}
	return nil, fmt.Errorf("unknown relation: %s", relation.TargetSchema)
}

// apply{{ $node.Name }}WithEdges applies eager loading for the given edge paths
func apply{{ $node.Name }}WithEdges(q *{{ $node.Name }}Query, edgePaths []vent.EdgePath) *{{ $node.Name }}Query {
	for _, ep := range edgePaths {
		switch ep.Name {
		{{- range $edge := $node.Edges }}
		{{- if not $edge.Unique }}
		case "{{ $edge.Name }}":
			q = q.With{{ pascal $edge.Name }}(func(childQ *{{ $edge.Type.Name }}Query) {
				{{- if $edge.Type.Edges }}
				// Apply nested eager loading
				if len(ep.Children) > 0 {
					apply{{ $edge.Type.Name }}WithEdges(childQ, ep.Children)
				}
				{{- end }}
			})
		{{- end }}
		{{- end }}
		}
	}
	return q
}

// {{ lower $node.Name }}ToEntityData converts a {{ $node.Name }} entity to EntityData
func {{ lower $node.Name }}ToEntityData(e *{{ $node.Name }}) vent.EntityData {
	data := vent.EntityData{
		"id": vent.NewIntFieldValue(e.ID),
		{{ range $field := $node.Fields }}
		"{{ $field.Name }}": vent.New{{ pascal $field.Type.Type.String }}FieldValue(e.{{ pascal $field.Name }}),
		{{ end }}
	}

	// Add foreign key fields with relation info
	{{- range $edge := $node.Edges }}
	{{- if $edge.Unique }}
	if e.Edges.{{ pascal $edge.Name }} != nil {
		data["{{ $edge.Name }}_id"] = vent.NewForeignKeyFieldValue(
			e.Edges.{{ pascal $edge.Name }}.ID,
			vent.RelationValue{
				TargetSchema: "{{ $edge.Type.Name }}",
				TargetID:     e.Edges.{{ pascal $edge.Name }}.ID,
				TargetLabel:  fmt.Sprintf("%d", e.Edges.{{ pascal $edge.Name }}.ID), // TODO: Use display field
				TargetPath:   "{{ $adminPath }}{{ lower $edge.Type.Name }}s/",
			},
		)
	}
	{{- end }}
	{{- end }}

	// Add loaded edge relations
	{{- range $edge := $node.Edges }}
	{{- if not $edge.Unique }}
	if len(e.Edges.{{ pascal $edge.Name }}) > 0 || e.Edges.loadedTypes[{{ $edge.Index }}] {
		relatedEntities := make([]vent.EntityData, len(e.Edges.{{ pascal $edge.Name }}))
		for i, related := range e.Edges.{{ pascal $edge.Name }} {
			relatedEntities[i] = {{ lower $edge.Type.Name }}ToEntityData(related)
		}
		data["{{ $edge.Name }}"] = vent.NewRelationFieldValue(vent.RelationData{
			TargetSchema: "{{ $edge.Type.Name }}",
			TargetPath:   "{{ $adminPath }}{{ lower $edge.Type.Name }}s/",
			Entities:     relatedEntities,
			Loaded:       true,
		})
	}
	{{- end }}
	{{- end }}

	return data
}

{{ end }}

{{ end }}
